# Tree's

[Introduction Page](0-Introduction.md)

## Introduction

Tree's, exactly as they sound. Don't make them more complex than they need to be, it's already going to be a struggle. 

## Binary Tree's

Binary Search Tree's, aka BST is the typical 

Root - 

Parent - 

Child - 

Leaf/Leaves - 

## Commands

Common BST Operation | Description | COde? | Big O Notation
----- | ----- | ----- | -----
<b>insert(valule) | Insert a Value into the tree | `code here` | O(log n) - Recurlsivly Search the Subtrees to find the next avaliable spot
<b>remove(value) | Remove a value from the tree | `code here` | O(log n) - Recursively search the subtrees to find the value and remove it, require cleanup of affected nodes
<b>Contains(value) | Determine if a value is in the tree | `code here` | O(log n) - recursily search the subtrees to find the value
<b>traverse_forward | visit all objects from smallest to largest | `code here` | O(n) - Recursively travese the left subtree, then the right subtree
<b>traverse_reverse | Visit all objecst from largest to smallest | `code here` | O(n) - Recusively traverse the right subtree, then the left subtree
<b>height(node) | Determine ht eheight of a node. If the height of the tree is needed, the root node is provided. | `code here` | O(n) - Recusitly find the height of the left and right subtrees and then return the maximun height (plus one to accound for the root)
<b>size() | Return the size of the BST | `code here` | O(1) - The size is maintained within the BST class
<b> empty() | Returns true if the root node is empty, same as size = 0 | `code here` | O(1) - The comparison of the root node of the size


## Example

I hope coming up with this wont take too long....

## Problem to Solve

I don't know if this will be better or worse than the previous one.